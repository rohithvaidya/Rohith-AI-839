[
  {
    "objectID": "reference/train_model.html",
    "href": "reference/train_model.html",
    "title": "train_model",
    "section": "",
    "text": "train_model\ntrain_model(X_train, y_train)\nTrains the Logistic regression model.\nArgs: X_train: Training data of independent features. y_train: Training data for target decision.\nReturns: Trained model.",
    "crumbs": [
      "ML Stagewise Documentation",
      "train_model"
    ]
  },
  {
    "objectID": "reference/sklearn.html",
    "href": "reference/sklearn.html",
    "title": "sklearn",
    "section": "",
    "text": "sklearn\nsklearn\nConfigure global settings and get information about the working environment."
  },
  {
    "objectID": "reference/Report.html",
    "href": "reference/Report.html",
    "title": "Report",
    "section": "",
    "text": "Report\nreport.Report(self, metrics, options=None, timestamp=None, id=None, metadata=None, tags=None, model_id=None, reference_id=None, batch_size=None, dataset_id=None, name=None)"
  },
  {
    "objectID": "reference/preview.html",
    "href": "reference/preview.html",
    "title": "preview",
    "section": "",
    "text": "preview(ast, max_depth=999, compact=False, as_string=False)\nPrint a friendly representation of a griffe object (e.g. function, docstring)\n\n\n&gt;&gt;&gt; from quartodoc import get_object\n&gt;&gt;&gt; obj = get_object(\"quartodoc\", \"get_object\")\n&gt;&gt;&gt; preview(obj.docstring.parsed)\n ...\n&gt;&gt;&gt; preview(obj)\n ..."
  },
  {
    "objectID": "reference/preview.html#examples",
    "href": "reference/preview.html#examples",
    "title": "preview",
    "section": "",
    "text": "&gt;&gt;&gt; from quartodoc import get_object\n&gt;&gt;&gt; obj = get_object(\"quartodoc\", \"get_object\")\n&gt;&gt;&gt; preview(obj.docstring.parsed)\n ...\n&gt;&gt;&gt; preview(obj)\n ..."
  },
  {
    "objectID": "reference/plot_and_save.html",
    "href": "reference/plot_and_save.html",
    "title": "plot_and_save",
    "section": "",
    "text": "plot_and_save(column_name, current_data, reference_data)\nPlots and saves the probability density distribution for a specified column.\nThis function compares the probability density distribution between the current and reference datasets for a specified column. It creates a line plot for both datasets and saves the plot as a PNG file to a predefined location.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumn_name\nstr\nThe name of the column for which the distribution plot is generated.\nrequired\n\n\ncurrent_data\npd.DataFrame\nThe current dataset containing columns ‘x’ (values) and ‘y’ (probability densities).\nrequired\n\n\nreference_data\npd.DataFrame\nThe reference dataset containing columns ‘x’ (values) and ‘y’ (probability densities).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nNone\nThis function does not return any value, but saves the generated plot as a PNG file.\n\n\n\n\n\n\nA PNG file named after the column is saved to ‘data/08_reporting/’ containing the distribution plot for the specified column.",
    "crumbs": [
      "ML Stagewise Documentation",
      "plot_and_save"
    ]
  },
  {
    "objectID": "reference/plot_and_save.html#parameters",
    "href": "reference/plot_and_save.html#parameters",
    "title": "plot_and_save",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncolumn_name\nstr\nThe name of the column for which the distribution plot is generated.\nrequired\n\n\ncurrent_data\npd.DataFrame\nThe current dataset containing columns ‘x’ (values) and ‘y’ (probability densities).\nrequired\n\n\nreference_data\npd.DataFrame\nThe reference dataset containing columns ‘x’ (values) and ‘y’ (probability densities).\nrequired",
    "crumbs": [
      "ML Stagewise Documentation",
      "plot_and_save"
    ]
  },
  {
    "objectID": "reference/plot_and_save.html#returns",
    "href": "reference/plot_and_save.html#returns",
    "title": "plot_and_save",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nNone\nThis function does not return any value, but saves the generated plot as a PNG file.",
    "crumbs": [
      "ML Stagewise Documentation",
      "plot_and_save"
    ]
  },
  {
    "objectID": "reference/plot_and_save.html#side-effects",
    "href": "reference/plot_and_save.html#side-effects",
    "title": "plot_and_save",
    "section": "",
    "text": "A PNG file named after the column is saved to ‘data/08_reporting/’ containing the distribution plot for the specified column.",
    "crumbs": [
      "ML Stagewise Documentation",
      "plot_and_save"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Modeling Stage\n\n\n\nLogisticRegression\nLogistic Regression (aka logit, MaxEnt) classifier.\n\n\n\n\n\n\nDrfit Stage\n\n\n\nDataDriftPreset\nMetric Preset for Data Drift analysis.\n\n\n\n\n\n\nNodes\n\n\n\nsplit_data\nSplits data into features and targets training and test sets.\n\n\ntrain_model\nTrains the Logistic regression model.\n\n\nquality_drift_check\nChecks for data drift between training and test datasets using predefined metrics.\n\n\nevaluate_model\nCalculates and logs the coefficient of determination.\n\n\nprediction_drift_check\nChecks for prediction drift between the true and predicted values.\n\n\nplot_and_save\nPlots and saves the probability density distribution for a specified column.\n\n\nreport_plotly\nGenerates and saves distribution plots for data and prediction drift using Plotly.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#ml-stagewise-documentation",
    "href": "reference/index.html#ml-stagewise-documentation",
    "title": "Function reference",
    "section": "",
    "text": "Modeling Stage\n\n\n\nLogisticRegression\nLogistic Regression (aka logit, MaxEnt) classifier.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#ml-stagewise-documentation-1",
    "href": "reference/index.html#ml-stagewise-documentation-1",
    "title": "Function reference",
    "section": "",
    "text": "Drfit Stage\n\n\n\nDataDriftPreset\nMetric Preset for Data Drift analysis.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#ml-stagewise-documentation-2",
    "href": "reference/index.html#ml-stagewise-documentation-2",
    "title": "Function reference",
    "section": "",
    "text": "Nodes\n\n\n\nsplit_data\nSplits data into features and targets training and test sets.\n\n\ntrain_model\nTrains the Logistic regression model.\n\n\nquality_drift_check\nChecks for data drift between training and test datasets using predefined metrics.\n\n\nevaluate_model\nCalculates and logs the coefficient of determination.\n\n\nprediction_drift_check\nChecks for prediction drift between the true and predicted values.\n\n\nplot_and_save\nPlots and saves the probability density distribution for a specified column.\n\n\nreport_plotly\nGenerates and saves distribution plots for data and prediction drift using Plotly.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/evaluate_model.html",
    "href": "reference/evaluate_model.html",
    "title": "evaluate_model",
    "section": "",
    "text": "evaluate_model\nevaluate_model(regressor, X_test, y_test)\nCalculates and logs the coefficient of determination.\nArgs: regressor: Trained model. X_test: Testing data of independent features. y_test: Testing data for target decision.",
    "crumbs": [
      "ML Stagewise Documentation",
      "evaluate_model"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "quarto",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "reference/DataDriftPreset.html",
    "href": "reference/DataDriftPreset.html",
    "title": "DataDriftPreset",
    "section": "",
    "text": "DataDriftPreset\nmetric_preset.DataDriftPreset(self, columns=None, embeddings=None, embeddings_drift_method=None, drift_share=0.5, stattest=None, cat_stattest=None, num_stattest=None, text_stattest=None, per_column_stattest=None, stattest_threshold=None, cat_stattest_threshold=None, num_stattest_threshold=None, text_stattest_threshold=None, per_column_stattest_threshold=None)\nMetric Preset for Data Drift analysis.\nContains metrics: - DatasetDriftMetric - DataDriftTable - EmbeddingsDriftMetric",
    "crumbs": [
      "ML Stagewise Documentation",
      "DataDriftPreset"
    ]
  },
  {
    "objectID": "reference/get_object.html",
    "href": "reference/get_object.html",
    "title": "get_object",
    "section": "",
    "text": "get_object(path, object_name=None, parser='numpy', load_aliases=True, dynamic=False, loader=None)\nFetch a griffe object.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr\nAn import path to the object. This should have the form path.to.module:object. For example, quartodoc:get_object or quartodoc:MdRenderer.render.\nrequired\n\n\nobject_name\n‘str | None’\n(Deprecated). A function name.\nNone\n\n\nparser\nstr\nA docstring parser to use.\n'numpy'\n\n\nload_aliases\n\nFor aliases that were imported from other modules, should we load that module?\nTrue\n\n\ndynamic\n\nWhether to dynamically import object. Useful if docstring is not hard-coded, but was set on object by running python code.\nFalse\n\n\n\n\n\n\npreview: print a user-friendly preview of a griffe object.\n\n\n\n&gt;&gt;&gt; get_function(\"quartodoc\", \"get_function\")\n&lt;Function('get_function', ...\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndc.Object\nabc"
  },
  {
    "objectID": "reference/get_object.html#parameters",
    "href": "reference/get_object.html#parameters",
    "title": "get_object",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\npath\nstr\nAn import path to the object. This should have the form path.to.module:object. For example, quartodoc:get_object or quartodoc:MdRenderer.render.\nrequired\n\n\nobject_name\n‘str | None’\n(Deprecated). A function name.\nNone\n\n\nparser\nstr\nA docstring parser to use.\n'numpy'\n\n\nload_aliases\n\nFor aliases that were imported from other modules, should we load that module?\nTrue\n\n\ndynamic\n\nWhether to dynamically import object. Useful if docstring is not hard-coded, but was set on object by running python code.\nFalse"
  },
  {
    "objectID": "reference/get_object.html#see-also",
    "href": "reference/get_object.html#see-also",
    "title": "get_object",
    "section": "",
    "text": "preview: print a user-friendly preview of a griffe object."
  },
  {
    "objectID": "reference/get_object.html#examples",
    "href": "reference/get_object.html#examples",
    "title": "get_object",
    "section": "",
    "text": "&gt;&gt;&gt; get_function(\"quartodoc\", \"get_function\")\n&lt;Function('get_function', ..."
  },
  {
    "objectID": "reference/get_object.html#returns",
    "href": "reference/get_object.html#returns",
    "title": "get_object",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\ndc.Object\nabc"
  },
  {
    "objectID": "reference/LogisticRegression.html",
    "href": "reference/LogisticRegression.html",
    "title": "LogisticRegression",
    "section": "",
    "text": "linear_model.LogisticRegression(self, penalty='l2', *, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver='lbfgs', max_iter=100, multi_class='deprecated', verbose=0, warm_start=False, n_jobs=None, l1_ratio=None)\nLogistic Regression (aka logit, MaxEnt) classifier.\nIn the multiclass case, the training algorithm uses the one-vs-rest (OvR) scheme if the ‘multi_class’ option is set to ‘ovr’, and uses the cross-entropy loss if the ‘multi_class’ option is set to ‘multinomial’. (Currently the ‘multinomial’ option is supported only by the ‘lbfgs’, ‘sag’, ‘saga’ and ‘newton-cg’ solvers.)\nThis class implements regularized logistic regression using the ‘liblinear’ library, ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’ solvers. Note that regularization is applied by default. It can handle both dense and sparse input. Use C-ordered arrays or CSR matrices containing 64-bit floats for optimal performance; any other input format will be converted (and copied).\nThe ‘newton-cg’, ‘sag’, and ‘lbfgs’ solvers support only L2 regularization with primal formulation, or no regularization. The ‘liblinear’ solver supports both L1 and L2 regularization, with a dual formulation only for the L2 penalty. The Elastic-Net regularization is only supported by the ‘saga’ solver.\nRead more in the :ref:User Guide &lt;logistic_regression&gt;.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npenalty\n(l1, l2, elasticnet, None)\nSpecify the norm of the penalty: - None: no penalty is added; - 'l2': add a L2 penalty term and it is the default choice; - 'l1': add a L1 penalty term; - 'elasticnet': both L1 and L2 penalty terms are added. .. warning:: Some penalties may not work with some solvers. See the parameter solver below, to know the compatibility between the penalty and solver. .. versionadded:: 0.19 l1 penalty with SAGA solver (allowing ‘multinomial’ + L1)\n'l1'\n\n\ndual\nbool\nDual (constrained) or primal (regularized, see also :ref:this equation &lt;regularized-logistic-loss&gt;) formulation. Dual formulation is only implemented for l2 penalty with liblinear solver. Prefer dual=False when n_samples &gt; n_features.\nFalse\n\n\ntol\nfloat\nTolerance for stopping criteria.\n1e-4\n\n\nC\nfloat\nInverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.\n1.0\n\n\nfit_intercept\nbool\nSpecifies if a constant (a.k.a. bias or intercept) should be added to the decision function.\nTrue\n\n\nintercept_scaling\nfloat\nUseful only when the solver ‘liblinear’ is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a “synthetic” feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight. Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept_scaling has to be increased.\n1\n\n\nclass_weight\ndict or balanced\nWeights associated with classes in the form {class_label: weight}. If not given, all classes are supposed to have weight one. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)). Note that these weights will be multiplied with sample_weight (passed through the fit method) if sample_weight is specified. .. versionadded:: 0.17 class_weight=‘balanced’\nNone\n\n\nrandom_state\nint, RandomState instance\nUsed when solver == ‘sag’, ‘saga’ or ‘liblinear’ to shuffle the data. See :term:Glossary &lt;random_state&gt; for details.\nNone\n\n\nsolver\n(lbfgs, liblinear, newton - cg, newton - cholesky, sag, saga)\nAlgorithm to use in the optimization problem. Default is ‘lbfgs’. To choose a solver, you might want to consider the following aspects: - For small datasets, ‘liblinear’ is a good choice, whereas ‘sag’ and ‘saga’ are faster for large ones; - For multiclass problems, only ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’ handle multinomial loss; - ‘liblinear’ and ‘newton-cholesky’ can only handle binary classification by default. To apply a one-versus-rest scheme for the multiclass setting one can wrapt it with the OneVsRestClassifier. - ‘newton-cholesky’ is a good choice for n_samples &gt;&gt; n_features, especially with one-hot encoded categorical features with rare categories. Be aware that the memory usage of this solver has a quadratic dependency on n_features because it explicitly computes the Hessian matrix. .. warning:: The choice of the algorithm depends on the penalty chosen and on (multinomial) multiclass support: ================= ============================== ====================== solver penalty multinomial multiclass ================= ============================== ====================== ‘lbfgs’ ‘l2’, None yes ‘liblinear’ ‘l1’, ‘l2’ no ‘newton-cg’ ‘l2’, None yes ‘newton-cholesky’ ‘l2’, None no ‘sag’ ‘l2’, None yes ‘saga’ ‘elasticnet’, ‘l1’, ‘l2’, None yes ================= ============================== ====================== .. note:: ‘sag’ and ‘saga’ fast convergence is only guaranteed on features with approximately the same scale. You can preprocess the data with a scaler from :mod:sklearn.preprocessing. .. seealso:: Refer to the User Guide for more information regarding :class:LogisticRegression and more specifically the :ref:Table &lt;Logistic_regression&gt; summarizing solver/penalty supports. .. versionadded:: 0.17 Stochastic Average Gradient descent solver. .. versionadded:: 0.19 SAGA solver. .. versionchanged:: 0.22 The default solver changed from ‘liblinear’ to ‘lbfgs’ in 0.22. .. versionadded:: 1.2 newton-cholesky solver.\n'lbfgs'\n\n\nmax_iter\nint\nMaximum number of iterations taken for the solvers to converge.\n100\n\n\nmulti_class\n(auto, ovr, multinomial)\nIf the option chosen is ‘ovr’, then a binary problem is fit for each label. For ‘multinomial’ the loss minimised is the multinomial loss fit across the entire probability distribution, even when the data is binary. ‘multinomial’ is unavailable when solver=‘liblinear’. ‘auto’ selects ‘ovr’ if the data is binary, or if solver=‘liblinear’, and otherwise selects ‘multinomial’. .. versionadded:: 0.18 Stochastic Average Gradient descent solver for ‘multinomial’ case. .. versionchanged:: 0.22 Default changed from ‘ovr’ to ‘auto’ in 0.22. .. deprecated:: 1.5 multi_class was deprecated in version 1.5 and will be removed in 1.7. From then on, the recommended ‘multinomial’ will always be used for n_classes &gt;= 3. Solvers that do not support ‘multinomial’ will raise an error. Use sklearn.multiclass.OneVsRestClassifier(LogisticRegression()) if you still want to use OvR.\n'auto'\n\n\nverbose\nint\nFor the liblinear and lbfgs solvers set verbose to any positive number for verbosity.\n0\n\n\nwarm_start\nbool\nWhen set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. Useless for liblinear solver. See :term:the Glossary &lt;warm_start&gt;. .. versionadded:: 0.17 warm_start to support lbfgs, newton-cg, sag, saga solvers.\nFalse\n\n\nn_jobs\nint\nNumber of CPU cores used when parallelizing over classes if multi_class=‘ovr’“. This parameter is ignored when the solver is set to ‘liblinear’ regardless of whether ‘multi_class’ is specified or not. None means 1 unless in a :obj:joblib.parallel_backend context. -1 means using all processors. See :term:Glossary &lt;n_jobs&gt; for more details.\nNone\n\n\nl1_ratio\nfloat\nThe Elastic-Net mixing parameter, with 0 &lt;= l1_ratio &lt;= 1. Only used if penalty='elasticnet'. Setting l1_ratio=0 is equivalent to using penalty='l2', while setting l1_ratio=1 is equivalent to using penalty='l1'. For 0 &lt; l1_ratio &lt;1, the penalty is a combination of L1 and L2.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nclasses_\nndarray of shape (n_classes, )\nA list of class labels known to the classifier.\n\n\ncoef_\nndarray of shape (1, n_features) or (n_classes, n_features)\nCoefficient of the features in the decision function. coef_ is of shape (1, n_features) when the given problem is binary. In particular, when multi_class='multinomial', coef_ corresponds to outcome 1 (True) and -coef_ corresponds to outcome 0 (False).\n\n\nintercept_\nndarray of shape (1,) or (n_classes,)\nIntercept (a.k.a. bias) added to the decision function. If fit_intercept is set to False, the intercept is set to zero. intercept_ is of shape (1,) when the given problem is binary. In particular, when multi_class='multinomial', intercept_ corresponds to outcome 1 (True) and -intercept_ corresponds to outcome 0 (False).\n\n\nn_features_in_\nint\nNumber of features seen during :term:fit. .. versionadded:: 0.24\n\n\nfeature_names_in_\nndarray of shape (n_features_in_,)\nNames of features seen during :term:fit. Defined only when X has feature names that are all strings. .. versionadded:: 1.0\n\n\nn_iter_\nndarray of shape (n_classes,) or (1, )\nActual number of iterations for all classes. If binary or multinomial, it returns only 1 element. For liblinear solver, only the maximum number of iteration across all classes is given. .. versionchanged:: 0.20 In SciPy &lt;= 1.0.0 the number of lbfgs iterations may exceed max_iter. n_iter_ will now report at most max_iter.\n\n\n\n\n\n\nSGDClassifier : Incrementally trained logistic regression (when given the parameter loss=\"log_loss\"). LogisticRegressionCV : Logistic regression with built-in cross validation.\n\n\n\nThe underlying C implementation uses a random number generator to select features when fitting the model. It is thus not uncommon, to have slightly different results for the same input data. If that happens, try with a smaller tol parameter.\nPredict output may not match that of standalone liblinear in certain cases. See :ref:differences from liblinear &lt;liblinear_differences&gt; in the narrative documentation.\n\n\n\nL-BFGS-B – Software for Large-scale Bound-constrained Optimization Ciyou Zhu, Richard Byrd, Jorge Nocedal and Jose Luis Morales. http://users.iems.northwestern.edu/~nocedal/lbfgsb.html\nLIBLINEAR – A Library for Large Linear Classification https://www.csie.ntu.edu.tw/~cjlin/liblinear/\nSAG – Mark Schmidt, Nicolas Le Roux, and Francis Bach Minimizing Finite Sums with the Stochastic Average Gradient https://hal.inria.fr/hal-00860051/document\nSAGA – Defazio, A., Bach F. & Lacoste-Julien S. (2014). :arxiv:\"SAGA: A Fast Incremental Gradient Method With Support         for Non-Strongly Convex Composite Objectives\" &lt;1407.0202&gt;\nHsiang-Fu Yu, Fang-Lan Huang, Chih-Jen Lin (2011). Dual coordinate descent methods for logistic regression and maximum entropy models. Machine Learning 85(1-2):41-75. https://www.csie.ntu.edu.tw/~cjlin/papers/maxent_dual.pdf\n\n\n\n&gt;&gt;&gt; from sklearn.datasets import load_iris\n&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression\n&gt;&gt;&gt; X, y = load_iris(return_X_y=True)\n&gt;&gt;&gt; clf = LogisticRegression(random_state=0).fit(X, y)\n&gt;&gt;&gt; clf.predict(X[:2, :])\narray([0, 0])\n&gt;&gt;&gt; clf.predict_proba(X[:2, :])\narray([[9.8...e-01, 1.8...e-02, 1.4...e-08],\n       [9.7...e-01, 2.8...e-02, ...e-08]])\n&gt;&gt;&gt; clf.score(X, y)\n0.97...\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfit\nFit the model according to the given training data.\n\n\npredict_log_proba\nPredict logarithm of probability estimates.\n\n\npredict_proba\nProbability estimates.\n\n\n\n\n\nlinear_model.LogisticRegression.fit(X, y, sample_weight=None)\nFit the model according to the given training data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\narray-like, sparse matrix\nTraining vector, where n_samples is the number of samples and n_features is the number of features.\narray-like\n\n\ny\narray-like of shape (n_samples,)\nTarget vector relative to X.\nrequired\n\n\nsample_weight\narray-like of shape (n_samples,) default=None\nArray of weights that are assigned to individual samples. If not provided, then each sample is given unit weight. .. versionadded:: 0.17 sample_weight support to LogisticRegression.\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nself\nFitted estimator.\n\n\n\n\n\n\nThe SAGA solver supports both float64 and float32 bit arrays.\n\n\n\n\nlinear_model.LogisticRegression.predict_log_proba(X)\nPredict logarithm of probability estimates.\nThe returned estimates for all classes are ordered by the label of classes.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\narray-like of shape (n_samples, n_features)\nVector to be scored, where n_samples is the number of samples and n_features is the number of features.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\narray-like of shape (n_samples, n_classes)\nReturns the log-probability of the sample for each class in the model, where classes are ordered as they are in self.classes_.\n\n\n\n\n\n\n\nlinear_model.LogisticRegression.predict_proba(X)\nProbability estimates.\nThe returned estimates for all classes are ordered by the label of classes.\nFor a multi_class problem, if multi_class is set to be “multinomial” the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e. calculate the probability of each class assuming it to be positive using the logistic function and normalize these values across all the classes.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\narray-like of shape (n_samples, n_features)\nVector to be scored, where n_samples is the number of samples and n_features is the number of features.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\narray-like of shape (n_samples, n_classes)\nReturns the probability of the sample for each class in the model, where classes are ordered as they are in self.classes_.",
    "crumbs": [
      "ML Stagewise Documentation",
      "LogisticRegression"
    ]
  },
  {
    "objectID": "reference/LogisticRegression.html#parameters",
    "href": "reference/LogisticRegression.html#parameters",
    "title": "LogisticRegression",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\npenalty\n(l1, l2, elasticnet, None)\nSpecify the norm of the penalty: - None: no penalty is added; - 'l2': add a L2 penalty term and it is the default choice; - 'l1': add a L1 penalty term; - 'elasticnet': both L1 and L2 penalty terms are added. .. warning:: Some penalties may not work with some solvers. See the parameter solver below, to know the compatibility between the penalty and solver. .. versionadded:: 0.19 l1 penalty with SAGA solver (allowing ‘multinomial’ + L1)\n'l1'\n\n\ndual\nbool\nDual (constrained) or primal (regularized, see also :ref:this equation &lt;regularized-logistic-loss&gt;) formulation. Dual formulation is only implemented for l2 penalty with liblinear solver. Prefer dual=False when n_samples &gt; n_features.\nFalse\n\n\ntol\nfloat\nTolerance for stopping criteria.\n1e-4\n\n\nC\nfloat\nInverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.\n1.0\n\n\nfit_intercept\nbool\nSpecifies if a constant (a.k.a. bias or intercept) should be added to the decision function.\nTrue\n\n\nintercept_scaling\nfloat\nUseful only when the solver ‘liblinear’ is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a “synthetic” feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight. Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept_scaling has to be increased.\n1\n\n\nclass_weight\ndict or balanced\nWeights associated with classes in the form {class_label: weight}. If not given, all classes are supposed to have weight one. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)). Note that these weights will be multiplied with sample_weight (passed through the fit method) if sample_weight is specified. .. versionadded:: 0.17 class_weight=‘balanced’\nNone\n\n\nrandom_state\nint, RandomState instance\nUsed when solver == ‘sag’, ‘saga’ or ‘liblinear’ to shuffle the data. See :term:Glossary &lt;random_state&gt; for details.\nNone\n\n\nsolver\n(lbfgs, liblinear, newton - cg, newton - cholesky, sag, saga)\nAlgorithm to use in the optimization problem. Default is ‘lbfgs’. To choose a solver, you might want to consider the following aspects: - For small datasets, ‘liblinear’ is a good choice, whereas ‘sag’ and ‘saga’ are faster for large ones; - For multiclass problems, only ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’ handle multinomial loss; - ‘liblinear’ and ‘newton-cholesky’ can only handle binary classification by default. To apply a one-versus-rest scheme for the multiclass setting one can wrapt it with the OneVsRestClassifier. - ‘newton-cholesky’ is a good choice for n_samples &gt;&gt; n_features, especially with one-hot encoded categorical features with rare categories. Be aware that the memory usage of this solver has a quadratic dependency on n_features because it explicitly computes the Hessian matrix. .. warning:: The choice of the algorithm depends on the penalty chosen and on (multinomial) multiclass support: ================= ============================== ====================== solver penalty multinomial multiclass ================= ============================== ====================== ‘lbfgs’ ‘l2’, None yes ‘liblinear’ ‘l1’, ‘l2’ no ‘newton-cg’ ‘l2’, None yes ‘newton-cholesky’ ‘l2’, None no ‘sag’ ‘l2’, None yes ‘saga’ ‘elasticnet’, ‘l1’, ‘l2’, None yes ================= ============================== ====================== .. note:: ‘sag’ and ‘saga’ fast convergence is only guaranteed on features with approximately the same scale. You can preprocess the data with a scaler from :mod:sklearn.preprocessing. .. seealso:: Refer to the User Guide for more information regarding :class:LogisticRegression and more specifically the :ref:Table &lt;Logistic_regression&gt; summarizing solver/penalty supports. .. versionadded:: 0.17 Stochastic Average Gradient descent solver. .. versionadded:: 0.19 SAGA solver. .. versionchanged:: 0.22 The default solver changed from ‘liblinear’ to ‘lbfgs’ in 0.22. .. versionadded:: 1.2 newton-cholesky solver.\n'lbfgs'\n\n\nmax_iter\nint\nMaximum number of iterations taken for the solvers to converge.\n100\n\n\nmulti_class\n(auto, ovr, multinomial)\nIf the option chosen is ‘ovr’, then a binary problem is fit for each label. For ‘multinomial’ the loss minimised is the multinomial loss fit across the entire probability distribution, even when the data is binary. ‘multinomial’ is unavailable when solver=‘liblinear’. ‘auto’ selects ‘ovr’ if the data is binary, or if solver=‘liblinear’, and otherwise selects ‘multinomial’. .. versionadded:: 0.18 Stochastic Average Gradient descent solver for ‘multinomial’ case. .. versionchanged:: 0.22 Default changed from ‘ovr’ to ‘auto’ in 0.22. .. deprecated:: 1.5 multi_class was deprecated in version 1.5 and will be removed in 1.7. From then on, the recommended ‘multinomial’ will always be used for n_classes &gt;= 3. Solvers that do not support ‘multinomial’ will raise an error. Use sklearn.multiclass.OneVsRestClassifier(LogisticRegression()) if you still want to use OvR.\n'auto'\n\n\nverbose\nint\nFor the liblinear and lbfgs solvers set verbose to any positive number for verbosity.\n0\n\n\nwarm_start\nbool\nWhen set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. Useless for liblinear solver. See :term:the Glossary &lt;warm_start&gt;. .. versionadded:: 0.17 warm_start to support lbfgs, newton-cg, sag, saga solvers.\nFalse\n\n\nn_jobs\nint\nNumber of CPU cores used when parallelizing over classes if multi_class=‘ovr’“. This parameter is ignored when the solver is set to ‘liblinear’ regardless of whether ‘multi_class’ is specified or not. None means 1 unless in a :obj:joblib.parallel_backend context. -1 means using all processors. See :term:Glossary &lt;n_jobs&gt; for more details.\nNone\n\n\nl1_ratio\nfloat\nThe Elastic-Net mixing parameter, with 0 &lt;= l1_ratio &lt;= 1. Only used if penalty='elasticnet'. Setting l1_ratio=0 is equivalent to using penalty='l2', while setting l1_ratio=1 is equivalent to using penalty='l1'. For 0 &lt; l1_ratio &lt;1, the penalty is a combination of L1 and L2.\nNone",
    "crumbs": [
      "ML Stagewise Documentation",
      "LogisticRegression"
    ]
  },
  {
    "objectID": "reference/LogisticRegression.html#attributes",
    "href": "reference/LogisticRegression.html#attributes",
    "title": "LogisticRegression",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nclasses_\nndarray of shape (n_classes, )\nA list of class labels known to the classifier.\n\n\ncoef_\nndarray of shape (1, n_features) or (n_classes, n_features)\nCoefficient of the features in the decision function. coef_ is of shape (1, n_features) when the given problem is binary. In particular, when multi_class='multinomial', coef_ corresponds to outcome 1 (True) and -coef_ corresponds to outcome 0 (False).\n\n\nintercept_\nndarray of shape (1,) or (n_classes,)\nIntercept (a.k.a. bias) added to the decision function. If fit_intercept is set to False, the intercept is set to zero. intercept_ is of shape (1,) when the given problem is binary. In particular, when multi_class='multinomial', intercept_ corresponds to outcome 1 (True) and -intercept_ corresponds to outcome 0 (False).\n\n\nn_features_in_\nint\nNumber of features seen during :term:fit. .. versionadded:: 0.24\n\n\nfeature_names_in_\nndarray of shape (n_features_in_,)\nNames of features seen during :term:fit. Defined only when X has feature names that are all strings. .. versionadded:: 1.0\n\n\nn_iter_\nndarray of shape (n_classes,) or (1, )\nActual number of iterations for all classes. If binary or multinomial, it returns only 1 element. For liblinear solver, only the maximum number of iteration across all classes is given. .. versionchanged:: 0.20 In SciPy &lt;= 1.0.0 the number of lbfgs iterations may exceed max_iter. n_iter_ will now report at most max_iter.",
    "crumbs": [
      "ML Stagewise Documentation",
      "LogisticRegression"
    ]
  },
  {
    "objectID": "reference/LogisticRegression.html#see-also",
    "href": "reference/LogisticRegression.html#see-also",
    "title": "LogisticRegression",
    "section": "",
    "text": "SGDClassifier : Incrementally trained logistic regression (when given the parameter loss=\"log_loss\"). LogisticRegressionCV : Logistic regression with built-in cross validation.",
    "crumbs": [
      "ML Stagewise Documentation",
      "LogisticRegression"
    ]
  },
  {
    "objectID": "reference/LogisticRegression.html#notes",
    "href": "reference/LogisticRegression.html#notes",
    "title": "LogisticRegression",
    "section": "",
    "text": "The underlying C implementation uses a random number generator to select features when fitting the model. It is thus not uncommon, to have slightly different results for the same input data. If that happens, try with a smaller tol parameter.\nPredict output may not match that of standalone liblinear in certain cases. See :ref:differences from liblinear &lt;liblinear_differences&gt; in the narrative documentation.",
    "crumbs": [
      "ML Stagewise Documentation",
      "LogisticRegression"
    ]
  },
  {
    "objectID": "reference/LogisticRegression.html#references",
    "href": "reference/LogisticRegression.html#references",
    "title": "LogisticRegression",
    "section": "",
    "text": "L-BFGS-B – Software for Large-scale Bound-constrained Optimization Ciyou Zhu, Richard Byrd, Jorge Nocedal and Jose Luis Morales. http://users.iems.northwestern.edu/~nocedal/lbfgsb.html\nLIBLINEAR – A Library for Large Linear Classification https://www.csie.ntu.edu.tw/~cjlin/liblinear/\nSAG – Mark Schmidt, Nicolas Le Roux, and Francis Bach Minimizing Finite Sums with the Stochastic Average Gradient https://hal.inria.fr/hal-00860051/document\nSAGA – Defazio, A., Bach F. & Lacoste-Julien S. (2014). :arxiv:\"SAGA: A Fast Incremental Gradient Method With Support         for Non-Strongly Convex Composite Objectives\" &lt;1407.0202&gt;\nHsiang-Fu Yu, Fang-Lan Huang, Chih-Jen Lin (2011). Dual coordinate descent methods for logistic regression and maximum entropy models. Machine Learning 85(1-2):41-75. https://www.csie.ntu.edu.tw/~cjlin/papers/maxent_dual.pdf",
    "crumbs": [
      "ML Stagewise Documentation",
      "LogisticRegression"
    ]
  },
  {
    "objectID": "reference/LogisticRegression.html#examples",
    "href": "reference/LogisticRegression.html#examples",
    "title": "LogisticRegression",
    "section": "",
    "text": "&gt;&gt;&gt; from sklearn.datasets import load_iris\n&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression\n&gt;&gt;&gt; X, y = load_iris(return_X_y=True)\n&gt;&gt;&gt; clf = LogisticRegression(random_state=0).fit(X, y)\n&gt;&gt;&gt; clf.predict(X[:2, :])\narray([0, 0])\n&gt;&gt;&gt; clf.predict_proba(X[:2, :])\narray([[9.8...e-01, 1.8...e-02, 1.4...e-08],\n       [9.7...e-01, 2.8...e-02, ...e-08]])\n&gt;&gt;&gt; clf.score(X, y)\n0.97...",
    "crumbs": [
      "ML Stagewise Documentation",
      "LogisticRegression"
    ]
  },
  {
    "objectID": "reference/LogisticRegression.html#methods",
    "href": "reference/LogisticRegression.html#methods",
    "title": "LogisticRegression",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfit\nFit the model according to the given training data.\n\n\npredict_log_proba\nPredict logarithm of probability estimates.\n\n\npredict_proba\nProbability estimates.\n\n\n\n\n\nlinear_model.LogisticRegression.fit(X, y, sample_weight=None)\nFit the model according to the given training data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\narray-like, sparse matrix\nTraining vector, where n_samples is the number of samples and n_features is the number of features.\narray-like\n\n\ny\narray-like of shape (n_samples,)\nTarget vector relative to X.\nrequired\n\n\nsample_weight\narray-like of shape (n_samples,) default=None\nArray of weights that are assigned to individual samples. If not provided, then each sample is given unit weight. .. versionadded:: 0.17 sample_weight support to LogisticRegression.\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nself\nFitted estimator.\n\n\n\n\n\n\nThe SAGA solver supports both float64 and float32 bit arrays.\n\n\n\n\nlinear_model.LogisticRegression.predict_log_proba(X)\nPredict logarithm of probability estimates.\nThe returned estimates for all classes are ordered by the label of classes.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\narray-like of shape (n_samples, n_features)\nVector to be scored, where n_samples is the number of samples and n_features is the number of features.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\narray-like of shape (n_samples, n_classes)\nReturns the log-probability of the sample for each class in the model, where classes are ordered as they are in self.classes_.\n\n\n\n\n\n\n\nlinear_model.LogisticRegression.predict_proba(X)\nProbability estimates.\nThe returned estimates for all classes are ordered by the label of classes.\nFor a multi_class problem, if multi_class is set to be “multinomial” the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e. calculate the probability of each class assuming it to be positive using the logistic function and normalize these values across all the classes.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\narray-like of shape (n_samples, n_features)\nVector to be scored, where n_samples is the number of samples and n_features is the number of features.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\narray-like of shape (n_samples, n_classes)\nReturns the probability of the sample for each class in the model, where classes are ordered as they are in self.classes_.",
    "crumbs": [
      "ML Stagewise Documentation",
      "LogisticRegression"
    ]
  },
  {
    "objectID": "reference/prediction_drift_check.html",
    "href": "reference/prediction_drift_check.html",
    "title": "prediction_drift_check",
    "section": "",
    "text": "prediction_drift_check(y_test, y_pred)\nChecks for prediction drift between the true and predicted values.\nThis function runs a data drift analysis between the provided true values (y_test) and predicted values (y_pred). It generates a drift report using the Report class with the DataDriftPreset metrics, saves the report as an HTML file, and returns the drift report in JSON format.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ny_test\npd.Series\nThe reference true values (ground truth) to check for prediction drift.\nrequired\n\n\ny_pred\npd.Series\nThe predicted values to compare against the reference true values.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nA dictionary containing the drift report results in JSON format.\n\n\n\n\n\n\nAn HTML file named ‘evidently_plot.html’ is saved to ‘data/08_reporting/’ containing the visual report.",
    "crumbs": [
      "ML Stagewise Documentation",
      "prediction_drift_check"
    ]
  },
  {
    "objectID": "reference/prediction_drift_check.html#parameters",
    "href": "reference/prediction_drift_check.html#parameters",
    "title": "prediction_drift_check",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ny_test\npd.Series\nThe reference true values (ground truth) to check for prediction drift.\nrequired\n\n\ny_pred\npd.Series\nThe predicted values to compare against the reference true values.\nrequired",
    "crumbs": [
      "ML Stagewise Documentation",
      "prediction_drift_check"
    ]
  },
  {
    "objectID": "reference/prediction_drift_check.html#returns",
    "href": "reference/prediction_drift_check.html#returns",
    "title": "prediction_drift_check",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\ndict\nA dictionary containing the drift report results in JSON format.",
    "crumbs": [
      "ML Stagewise Documentation",
      "prediction_drift_check"
    ]
  },
  {
    "objectID": "reference/prediction_drift_check.html#side-effects",
    "href": "reference/prediction_drift_check.html#side-effects",
    "title": "prediction_drift_check",
    "section": "",
    "text": "An HTML file named ‘evidently_plot.html’ is saved to ‘data/08_reporting/’ containing the visual report.",
    "crumbs": [
      "ML Stagewise Documentation",
      "prediction_drift_check"
    ]
  },
  {
    "objectID": "reference/quality_drift_check.html",
    "href": "reference/quality_drift_check.html",
    "title": "quality_drift_check",
    "section": "",
    "text": "quality_drift_check(X_train, X_test)\nChecks for data drift between training and test datasets using predefined metrics.\nThis function runs a data drift analysis between the provided training (X_train) and test (X_test) datasets. It generates a drift report using the Report class with the DataDriftPreset metrics and returns the report in JSON format.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX_train\npd.DataFrame\nThe reference dataset (usually the training dataset) to check for data drift.\nrequired\n\n\nX_test\npd.DataFrame\nThe current dataset (usually the test dataset) to compare against the reference dataset.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ndict\nA dictionary containing the drift report results in JSON format.",
    "crumbs": [
      "ML Stagewise Documentation",
      "quality_drift_check"
    ]
  },
  {
    "objectID": "reference/quality_drift_check.html#parameters",
    "href": "reference/quality_drift_check.html#parameters",
    "title": "quality_drift_check",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nX_train\npd.DataFrame\nThe reference dataset (usually the training dataset) to check for data drift.\nrequired\n\n\nX_test\npd.DataFrame\nThe current dataset (usually the test dataset) to compare against the reference dataset.\nrequired",
    "crumbs": [
      "ML Stagewise Documentation",
      "quality_drift_check"
    ]
  },
  {
    "objectID": "reference/quality_drift_check.html#returns",
    "href": "reference/quality_drift_check.html#returns",
    "title": "quality_drift_check",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\ndict\nA dictionary containing the drift report results in JSON format.",
    "crumbs": [
      "ML Stagewise Documentation",
      "quality_drift_check"
    ]
  },
  {
    "objectID": "reference/report_plotly.html",
    "href": "reference/report_plotly.html",
    "title": "report_plotly",
    "section": "",
    "text": "report_plotly(data_drift, pred_drift)\nGenerates and saves distribution plots for data and prediction drift using Plotly.\nThis function processes the drift reports from the data drift and prediction drift analyses, extracts the small distribution data for each column, and generates distribution plots using the plot_and_save function. It handles both data drift and prediction drift reports, saving the resulting plots as PNG files.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_drift\ndict\nA dictionary containing the data drift report, including metrics and drift results by columns.\nrequired\n\n\npred_drift\ndict\nA dictionary containing the prediction drift report, including metrics and drift results by columns.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nNone\nThis function does not return any value, but saves the generated distribution plots as PNG files for each column.\n\n\n\n\n\n\nPNG files are saved to ‘data/08_reporting/’ for each column’s distribution plot based on the drift reports.",
    "crumbs": [
      "ML Stagewise Documentation",
      "report_plotly"
    ]
  },
  {
    "objectID": "reference/report_plotly.html#parameters",
    "href": "reference/report_plotly.html#parameters",
    "title": "report_plotly",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_drift\ndict\nA dictionary containing the data drift report, including metrics and drift results by columns.\nrequired\n\n\npred_drift\ndict\nA dictionary containing the prediction drift report, including metrics and drift results by columns.\nrequired",
    "crumbs": [
      "ML Stagewise Documentation",
      "report_plotly"
    ]
  },
  {
    "objectID": "reference/report_plotly.html#returns",
    "href": "reference/report_plotly.html#returns",
    "title": "report_plotly",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nNone\nThis function does not return any value, but saves the generated distribution plots as PNG files for each column.",
    "crumbs": [
      "ML Stagewise Documentation",
      "report_plotly"
    ]
  },
  {
    "objectID": "reference/report_plotly.html#side-effects",
    "href": "reference/report_plotly.html#side-effects",
    "title": "report_plotly",
    "section": "",
    "text": "PNG files are saved to ‘data/08_reporting/’ for each column’s distribution plot based on the drift reports.",
    "crumbs": [
      "ML Stagewise Documentation",
      "report_plotly"
    ]
  },
  {
    "objectID": "reference/split_data.html",
    "href": "reference/split_data.html",
    "title": "split_data",
    "section": "",
    "text": "split_data\nsplit_data(data, parameters)\nSplits data into features and targets training and test sets.\nArgs: data: Data containing features and target. parameters: Parameters defined in parameters/data_science.yml. Returns: Split data.",
    "crumbs": [
      "ML Stagewise Documentation",
      "split_data"
    ]
  }
]